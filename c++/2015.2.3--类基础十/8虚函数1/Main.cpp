#include <iostream>

//被virtual关键字修饰的成员函数就是虚函数
//如果子类中也有相同的返回值，名字，形式参数
//表的函数，那么子类的这个函数也是虚函数
//其virtual关键字可以写也可以不写

class A
{
public:
	void f1()
	{
		std::cout<<"A的f1"<<std::endl;
	}
	//[&A::f2]
	virtual void f2()
	{
		std::cout<<"A的f2"<<std::endl;
	}

};

class B : public A
{
public:
	void f1()
	{
		std::cout<<"B的f1"<<std::endl;
	}
	//[&B::f2]
	void f2()
	{
		std::cout<<"B的f2"<<std::endl;
	}
};

class C : public B
{
public:
	void f1()
	{
		std::cout<<"C的f1"<<std::endl;
	}
	//[&B::f2][&C::f3]
	virtual void f3()
	{}
};

//普通函数的调用
//对象调用普通函数，则对象是什么类型就调用什么
//类型的普通函数
//指针调用普通函数。则指针是什么类型的就调用什
//么类型的普通函数
//引用调用普通函数。则引用是什么类型的就调用什
//么类型的普通函数

//虚函数的调用
//对象调用虚函数，则对象是什么类型就调用什么
//类型的虚函数
//指针调用虚函数。则指针指向什么类型就调用什么
//类型的虚函数(多态)
//引用调用虚函数。则引用被什么类型初始化就调用
//什么类型的虚函数(多态)
void main()
{
	A x;
	B y;
	C z;
	
	A* p = &y;
	p->f1();//A::f1
	p->f2();//B::f2

	p = &z;
	p->f2();

	A& r = y;
	r.f1();//A::f1
	r.f2();//B::f2

	A& r1 = z;
	r1.f2();
	
	system("pause");
}

//一旦一个类拥有虚函数(无论多少).
//那么编译器将这个类做如下处理
//1)添加一个名字叫做__vfptr的指针,
//  该指针我们不能访问
//2)假设这个类有n个虚函数，那么在内存
//  空间中开辟4 * n个子节点连续的内存空间(虚函数表)
//  然后将其所有的虚函数的地址存放在开辟的
//  内存空间中
//3)如果这个类有子类，那么这个子类也拥有和
//  父类相同的虚函数表,如果子类重写了某个虚
//  函数，那么就把子类重写的这个虚函数的地址
//  来替换对应的父类里面的那个虚函数的地址
//4)子类可以添加新的虚函数，如果是这样的话。
//  子类的虚函数表就比父类的虚函数表要大
//5)C++在处理指针调用，引用调用虚函数的时候
//  做了一个间接的处理，让指针，引用先去根据
//  虚函数指针找到虚函数表，然后再调用虚函数
//  表中的虚函数