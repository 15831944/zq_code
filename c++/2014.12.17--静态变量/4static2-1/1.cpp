#include<iostream>
#include "2.h"

////静态
////static：
////01)修饰局部变量
//
//int f1()
//{
//	int a = 0;//分配a的内存
//	a += 1;
//	return a;
//}//释放a的内存

//int f2()
//{
//	//static 用法1:修饰局部变量的定义
//	//01)被修饰的局部变量是开辟在静态内存区(全局变量所在)
//	//02)其定义语句(可以有初始化)只是在最初执行一次，其后将
//	//不被执行
//	//03)其分配内存是在最初执行其定义语句的时候分配,在退出入口点
//	//函数之后释放内存，也就是说其分配释放都只有一次。和全局变量
//	//相同,和局部变量不同
//	//04)被static修饰的局部变量相当于只是被其所在的函数访问的全局
//	//变量,就比如下面的a相当于只是被f2函数访问的全局变量
//	//05)被static修饰的局部变量默认初始化为0
//	static int a = 0;
//	a += 1;
//	return  a;
//}

void main()
{
	//for(int i = 0; i < 5; ++i)
	//	std::cout<<f1()<<" ";
	//std::cout<<std::endl;

	//for(int i = 0; i < 5; ++i)
	//	std::cout<<f2()<<" ";
	//std::cout<<std::endl;

	x1 = 100;
	y1();
	//x2 = 100;
	//y2();
	
	//此处调用z函数就相当于间接的方式访问了x2
	//y2这两被static修饰的全局变量和函数
	z();

	//因为a数组被static修饰，那么在1.cpp中
	//就无法直接使用a这个标识符来访问数组，
	//我们可以使用GetNum,SetNum两个函数去间接
	//访问全局变量a数组，而这两个函数式绝对无
	//法破坏a数组，也就是说绝不可能出现越界的
	//情况。比如下面调用中其实a数组不会被写入,
	//因为SetNum检查了下标范围.
	SetNum(15,100);
	GetNum(14);
	system("pause");
}
